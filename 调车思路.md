# 记录调车的信息和思路


## 功能块的实现

### 通过串口实现命令行控制
- 命令行在代码中的实现
    - uart串口部分负责识别是否有命令输入，有就将uart4_to_do_flag置1
    - waitToDo部分判断uart4_to_do_flag是否置1而确定是否开始解析命令
    - command文件负责解析并执行命令
- 命令的首位是否需要特殊字符 不需要，只要每个命令都用回车结尾就行了
- 怎样实现命令行参数个数的识别
    - strtok分割函数
        - [strtok函数的使用](https://blog.csdn.net/buaa_shang/article/details/8189984)
        - [strtok函数的讲解](https://blog.csdn.net/weibo1230123/article/details/80177898)
        >对于strtok_r函数，如果第1个参数为NULL，就会从第3个参数开始（相当于第1个参数位置填入第3个参数）
    - sprintf
    - 将所有的命令简写为两个字符
- 怎样解析并执行命令
    -直接用switch语句


### 中断的优先级问题
- [怎么设置中断的优先级](http://www.vcan123.com/forum.php?mod=viewthread&tid=959&highlight=%D3%C5%CF%C8%BC%B6)

| 中断                 | 中断类型         | 中断优先级 |
|--------------------|------------------|------------|
| 命令行的中断         | UART4_RX_TX_IRQn | 3          |
| LCD的按键中断        | PORTD_IRQn       | 4          |
| 摄像头的DMA中断      | DMA0_IRQn        | 5          |
| 摄像头的场中断       | PORTA_IRQn       | 6          |
| 编码器的中断         | PIT0_IRQn        | 7          |
| 摄像头的采集图片中断 | PIT1_IRQn        | 8          |


### 摄像头
- 查看手册
- 直接参考别人代码提升性能
- 看山外的论坛
    - [山外论坛](http://www.vcan123.com/forum.php)
    - [山外鹰眼解压时间](http://www.vcan123.com/forum.php?mod=viewthread&tid=13652&ctid=6)
    - [山外整合资料](./source/K60中文资料整合版.pdf)
- 为什么PORTA_ISFR是写1来清标志位 因为这个寄存器是写1清0的，往里面写1赋值0
- 摄像头的代码
    - 图像的获取和处理都应该放在中断里
    - LCD的显示可以用预编译的手段放在摄像头的中断函数里面
    - 通过while来测试处理一张图片和处理一张图片并显示用的时间，再加一点时间作为中断的时间
    - 中断怎么用
        - 查看中断的例程
    - 采集一幅图像的时间长不长
        - 是采集的速度快还是将采集好的数组备份一份速度快

### 拒绝浮点数的运算


### 曲率的计算和舵机打角的控制
- 通过处理图像得到边缘
- 分别取出两个连续的赛道边的3个点
- 将总共6点的坐标进行梯形校正得到其实际的坐标位置（即真实世界的一个弯道，不管摄像头从远还是近观察，其曲率不变）
- 通过算法得到边缘的连续关系
- 计算出目标弯道的曲率
- 推算曲率和真实弯道半径的关系
- 推算真实弯道半径和舵机打角的关系
- 推算舵机打角和pwm占空比的关系

### 边缘连通的判断
- 边缘点的id编号从1开始


### 梯形校正与桶形失真
- 车子拍照传回电脑生成图片
- 编写桶形失真的代码 [桶形失真校正](https://blog.csdn.net/hyanglu1573/article/details/12876727)
    - 计算转化参数
        - 构建一个和原图大小相同的矩阵真图
        - 循环遍历真图的像素点，找出其对应于原图的位置
        - 调整参数，直到真图的直线不弯
    - 得出桶形失真的校正表
        - 测试出最小反向校正表
        - 构建一个比原图大的真图，反向映射到原图，得到60*80校正表
- 编写梯形校正的代码
    - 合并桶形失真的代码
    - 读取图片
    - 将图片转化到84*112矩阵
    - 求出透视变换矩阵
    - 显示透视变换处理后的图片
    - 生成校正表和反校正表并测试其正确性
- 合并两个校正表得到一个最后的校正表（输入一个图像点的坐标，得到一个真实世界中的坐标）



## tips

### 增加一对c和h文件时应注意
- h文件的ifdef要更改
- include文件要更新
- .c文件要加入工程
- .c的函数要在.h中声明
- 在主函数中加入代码块的初始化


### 函数找不到定义或声明
- go to definition 看看头文件里有没有全局的定义
- 看一下对应的c文件有没有这个函数
- 看一下对应的c文件有没有加入到工程


### 函数指针和指针函数
注意指针函数与函数指针表示方法不同，千万不要混淆。最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。
> 一个指针函数的例子，函数的返回值是指针
float *match();
float *p;
p = match(a);

函数指针图解
@import "./source/pic/函数指针.jpg"

### sobel算子边缘检测
- [sobel算子的原理讲解](https://blog.csdn.net/aiailab/article/details/82849158)
将像素点的数值看成是一个关于坐标的函数f(x,y),则函数有两个偏导
$$
\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}
$$
对于一个二维的平面来说，数值变化最快的方向是两个导数向量相加的方向，并且大小是
$$
\sqrt{\left(\frac{\partial f}{\partial x}\right)^{2}+\left(\frac{\partial f}{\partial y}\right)^{2}}
$$


### flash的操作
每次扇区写入4字节,数据地址每加一移动1个字节，因为程序里乘4，所以sector_offset加一，偏移4个字节
将图片的32个像素压缩一次写入4个字节
一幅图像占用的大小：60*80/8=600字节


芯片     | 每个扇区的字节数 | 扇区数
---------|------------------|----
MK60DZ10 | 2 * 1024         | 256
MK60F15  | 4 * 1024         | 128

主要通过3个变量来记录和控制flsah的操作
int picture_num = 0;	  //存储图片的数量
int picture_now_id = 0;   //当前的图片id,id从0开始
int picture_write_id = 0; //写入图片时，为图片分配的id

### 01代表黑白
NULL   | 黑 | 白
-------|----|--
摄像头 | 1  | 0
解压   | 0  | 1
压缩   | 1  | 0

所以送往LCD的都是1是黑，0是白
处理的时候用的都是解压的，所以1是白，0是黑
LCD_Img_Binary 将1解析成黑 0解析成白


### 滤波器
一幅图像包含着很多的信号，有高频也有低频，图片用黑白像素点表示
当图像中的一点翻转的时候代表这个信号分量被消除
图像中颜色一样的光斑聚集代表低频分量，颜色分散为高频分量
filter在滤波的时候
ans=src代表低通滤波器
ans=-src代表高通滤波器

@import "./source/pic/滤波器.png"



## 算法优化
- 图像处理时，解压的时候直接生成处理后的图像，因为索引耗时
- 所有计算可以换成位操作的全部换成位操作


## 零碎
- [unreachable code 错误解决办法](https://blog.csdn.net/majishushu/article/details/53262727)

- [浮点数文件](./Chip/src/IAR/system_MK60DZ10.c)50行

### 函数的宏定义
函数的宏定义可以设置函数的默认参数
> #define readPictureToLCDDefault() readPictureToDisplayer(picture_now_id, LCD)
指针的数组应用
> #define ans(i, j) (*(ans + 80 * (i) + (j)))
注意这里的80是列的数量，并且参数i,j都要加上括号(其实只有i是必须加的)
如果i出入的参数是a+1,没加括号则先执行80*a,就出错了

### 强制类型转化
同等存储长度的转化                    | 长转短               | 短转长
-----------------------------|-------------------|------------------
存储的数据完全不变，只是解析的方式不同 | 直接截取最后几位赋值 | 不是简单的加0，还包含符号位的传递

### opencv

[opencv配置技巧](https://blog.csdn.net/mars_xiaolei/article/details/78759041#commentBox)
[opencv配置新版](https://blog.csdn.net/weixin_42274148/article/details/85321091)



    






